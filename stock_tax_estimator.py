"""
stock_tax_estimator.py
----------------------
Estimate federal + state income taxes for salary and long-term capital gains.

Requires tax_data.yaml (generated by build_tax_data.py).

Usage:
    poetry run python stock_tax_estimator.py <salary> <stock_sales>
        [--year YEAR]
        [--state STATE]           # 2-letter postal code, e.g. CA, NY, TX
        [--filing-status STATUS]  # single | married | head_of_household

Examples:
    poetry run python stock_tax_estimator.py 200000 100000 --state CA
    poetry run python stock_tax_estimator.py 300000 500000 --year 2025 --state NY --filing-status married
    poetry run python stock_tax_estimator.py 150000 0 --state TX   # no state income tax
"""

import argparse
import datetime
import os
import sys
from typing import Optional

import yaml

DATA_DIR = os.path.dirname(os.path.abspath(__file__))
TAX_DATA_PATH = os.path.join(DATA_DIR, "tax_data.yaml")

FILING_STATUSES = ["single", "married", "head_of_household"]

# ---------------------------------------------------------------------------
# Data loading
# ---------------------------------------------------------------------------

_tax_data: Optional[dict] = None


def _load() -> dict:
    global _tax_data
    if _tax_data is None:
        if not os.path.isfile(TAX_DATA_PATH):
            print(
                f"Error: tax_data.yaml not found at {TAX_DATA_PATH}\n"
                f"Run:  poetry run python build_tax_data.py",
                file=sys.stderr,
            )
            sys.exit(1)
        with open(TAX_DATA_PATH, encoding="utf-8") as f:
            _tax_data = yaml.safe_load(f)
    return _tax_data


def _fed(year: int, key: str):
    return _load()["years"][year]["federal"][key]


def _state_record(year: int, code: str) -> Optional[dict]:
    return _load()["years"][year]["states"].get(code)


def supported_years() -> list[int]:
    return sorted(_load()["years"].keys())


# ---------------------------------------------------------------------------
# Core bracket engine
# ---------------------------------------------------------------------------

def _apply_brackets(taxable_income: float, brackets: list) -> float:
    """
    Apply a list of [[start, end, rate], ...] brackets to taxable_income.
    end == None means infinity.
    Brackets must be sorted by start ascending.
    """
    tax = 0.0
    for start, end, rate in brackets:
        if taxable_income <= start:
            break
        cap = float("inf") if end is None else end
        tax += (min(taxable_income, cap) - start) * rate
    return tax


# ---------------------------------------------------------------------------
# Federal calculations
# ---------------------------------------------------------------------------

def _calculate_federal_income_tax(
    salary: float,
    year: int,
    filing_status: str,
) -> dict:
    std_ded = _fed(year, "standard_deduction")[filing_status]
    taxable = max(0.0, salary - std_ded)
    tax = _apply_brackets(taxable, _fed(year, "brackets")[filing_status])
    return {
        "standard_deduction": std_ded,
        "taxable_income": taxable,
        "tax": tax,
    }


def _calculate_ltcg_tax(
    ordinary_income_base: float,
    stock_sales: float,
    year: int,
    filing_status: str,
) -> float:
    """
    Compute long-term capital gains tax using the stacking rule.
    LTCG is taxed at preferential rates but stacked on top of ordinary_income_base
    (which is federal_taxable_income for regular tax, or salary for AMT).
    """
    if stock_sales <= 0:
        return 0.0
    brackets = _fed(year, "ltcg_brackets")[filing_status]
    gains_top = ordinary_income_base + stock_sales
    tax = 0.0
    for start, end, rate in brackets:
        cap = float("inf") if end is None else end
        bracket_lo = max(start, ordinary_income_base)
        bracket_hi = min(cap, gains_top)
        if bracket_hi > bracket_lo:
            tax += (bracket_hi - bracket_lo) * rate
    return tax


def _calculate_niit(
    salary: float,
    stock_sales: float,
    year: int,
    filing_status: str,
) -> float:
    threshold = _fed(year, "niit_threshold")[filing_status]
    magi = salary + stock_sales
    niit_base = min(stock_sales, max(0.0, magi - threshold))
    return niit_base * 0.038


def _calculate_amt(
    salary: float,
    stock_sales: float,
    federal_income_tax: float,
    federal_capital_gains_tax: float,
    year: int,
    filing_status: str,
) -> dict:
    """
    Computes the federal Alternative Minimum Tax.

    Key rules:
    - Standard deduction is NOT allowed under AMT → AMTI = salary + stock_sales
    - LTCG retains preferential rates under AMT
    - AMT ordinary income is taxed at 26% / 28%
    - Additional AMT = max(0, TMT − (income_tax + capital_gains_tax))
      (NIIT is excluded from the regular-tax comparison per IRS rules)
    """
    amt_data = _fed(year, "amt")[filing_status]
    exemption = amt_data["exemption"]
    phaseout_threshold = amt_data["phaseout_threshold"]

    # AMTI — no standard deduction allowed
    amti = salary + stock_sales

    # Phaseout: exemption reduced by phaseout_rate for every $1 over the threshold.
    # 2025: 25 cents/dollar (TCJA);  2026: 50 cents/dollar (OBBBA — more aggressive)
    phaseout_rate = _fed(year, "amt_phaseout_rate")
    excess = max(0.0, amti - phaseout_threshold)
    reduced_exemption = max(0.0, exemption - phaseout_rate * excess)

    net_amti = max(0.0, amti - reduced_exemption)

    # Split net AMTI into ordinary and LTCG portions
    ltcg_in_amti    = min(stock_sales, net_amti)
    ordinary_net_amti = max(0.0, net_amti - ltcg_in_amti)

    # AMT on ordinary income: 26% up to breakpoint, 28% above
    bp = _fed(year, "amt_rate_breakpoint")
    if ordinary_net_amti <= bp:
        amt_ordinary = ordinary_net_amti * 0.26
    else:
        amt_ordinary = bp * 0.26 + (ordinary_net_amti - bp) * 0.28

    # AMT on LTCG: preferential rates, but stacked on ordinary_net_amti
    # (higher base than regular tax since no standard deduction under AMT)
    amt_ltcg = _calculate_ltcg_tax(ordinary_net_amti, ltcg_in_amti, year, filing_status)

    tmt = amt_ordinary + amt_ltcg
    regular_tax = federal_income_tax + federal_capital_gains_tax
    additional_amt = max(0.0, tmt - regular_tax)

    return {
        "amti": amti,
        "reduced_exemption": reduced_exemption,
        "net_amti": net_amti,
        "ordinary_net_amti": ordinary_net_amti,
        "ltcg_in_amti": ltcg_in_amti,
        "amt_ordinary": amt_ordinary,
        "amt_ltcg": amt_ltcg,
        "tentative_minimum_tax": tmt,
        "regular_tax_for_comparison": regular_tax,
        "additional_amt": additional_amt,
        "amt_applies": additional_amt > 0.005,  # small epsilon for float noise
    }


# ---------------------------------------------------------------------------
# State calculation
# ---------------------------------------------------------------------------

def _calculate_state_tax(
    salary: float,
    stock_sales: float,
    year: int,
    state_code: str,
    filing_status: str,
) -> dict:
    """Returns state tax details. state_code must be uppercase 2-letter postal code."""
    sd = _state_record(year, state_code)

    if sd is None:
        return {
            "state_code": state_code,
            "name": state_code,
            "no_income_tax": True,
            "reason": "state_not_in_data",
            "total_state_tax": 0.0,
            "state_income_tax": 0.0,
            "state_deduction": 0.0,
            "capital_gains_only": False,
        }

    if sd["no_income_tax"]:
        return {
            "state_code": state_code,
            "name": sd["name"],
            "no_income_tax": True,
            "reason": "no_income_tax",
            "total_state_tax": 0.0,
            "state_income_tax": 0.0,
            "state_deduction": 0.0,
            "capital_gains_only": False,
        }

    # Washington: capital gains only
    if sd["capital_gains_only"]:
        # HoH → use single deduction (no HoH distinction in state data)
        fs_key = "married" if filing_status == "married" else "single"
        cg_deduction = sd["capital_gains_deduction"][fs_key]
        taxable_gains = max(0.0, stock_sales - cg_deduction)
        cg_tax = _apply_brackets(taxable_gains, sd["capital_gains_brackets"])
        return {
            "state_code": state_code,
            "name": sd["name"],
            "no_income_tax": False,
            "capital_gains_only": True,
            "cg_deduction": cg_deduction,
            "state_income_tax": 0.0,
            "state_capital_gains_tax": cg_tax,
            "total_state_tax": cg_tax,
            "state_deduction": cg_deduction,
        }

    # Normal state: capital gains treated as ordinary income
    fs_key = "married" if filing_status == "married" else "single"
    std_ded = sd["standard_deduction"][fs_key]
    brackets = sd["brackets"][fs_key]
    taxable = max(0.0, salary + stock_sales - std_ded)
    state_tax = _apply_brackets(taxable, brackets)

    return {
        "state_code": state_code,
        "name": sd["name"],
        "no_income_tax": False,
        "capital_gains_only": False,
        "state_deduction": std_ded,
        "state_taxable_income": taxable,
        "state_income_tax": state_tax,
        "total_state_tax": state_tax,
    }


# ---------------------------------------------------------------------------
# Main orchestrator
# ---------------------------------------------------------------------------

def calculate_taxes(
    salary: float,
    stock_sales: float,
    year: int,
    state_code: Optional[str],
    filing_status: str,
) -> dict:
    if year not in supported_years():
        raise ValueError(
            f"Year {year} not supported. Available: {supported_years()}"
        )
    if filing_status not in FILING_STATUSES:
        raise ValueError(
            f"Filing status '{filing_status}' invalid. Choose: {FILING_STATUSES}"
        )

    # --- Federal ---
    fed = _calculate_federal_income_tax(salary, year, filing_status)
    federal_income_tax      = fed["tax"]
    federal_taxable_income  = fed["taxable_income"]
    standard_deduction      = fed["standard_deduction"]

    federal_capital_gains_tax = _calculate_ltcg_tax(
        federal_taxable_income, stock_sales, year, filing_status
    )
    niit = _calculate_niit(salary, stock_sales, year, filing_status)

    amt = _calculate_amt(
        salary, stock_sales,
        federal_income_tax, federal_capital_gains_tax,
        year, filing_status,
    )
    additional_amt = amt["additional_amt"]

    # --- State ---
    if state_code:
        state = _calculate_state_tax(salary, stock_sales, year, state_code, filing_status)
    else:
        state = {
            "state_code": None,
            "name": None,
            "no_income_tax": True,
            "reason": "no_state_specified",
            "total_state_tax": 0.0,
            "state_income_tax": 0.0,
            "state_deduction": 0.0,
            "capital_gains_only": False,
        }

    total_state_tax   = state["total_state_tax"]
    total_federal_tax = federal_income_tax + federal_capital_gains_tax + niit + additional_amt
    total_tax         = total_federal_tax + total_state_tax
    gross_income      = salary + stock_sales
    effective_rate    = (total_tax / gross_income * 100) if gross_income > 0 else 0.0

    return {
        # Inputs
        "year":           year,
        "filing_status":  filing_status,
        "state_code":     state_code,
        "salary":         salary,
        "stock_sales":    stock_sales,
        "gross_income":   gross_income,
        # Federal income
        "standard_deduction":          standard_deduction,
        "federal_taxable_income":      federal_taxable_income,
        "federal_income_tax":          federal_income_tax,
        # Federal LTCG
        "federal_capital_gains_tax":   federal_capital_gains_tax,
        # NIIT
        "niit":                        niit,
        # AMT
        "amt":                         amt,
        "additional_amt":              additional_amt,
        # State
        "state":                       state,
        "total_state_tax":             total_state_tax,
        # Totals
        "total_federal_tax":           total_federal_tax,
        "total_tax":                   total_tax,
        "effective_tax_rate":          effective_rate,
        "take_home_pay":               gross_income - total_tax,
    }


# ---------------------------------------------------------------------------
# Output formatting
# ---------------------------------------------------------------------------

_W = 46   # label column width
_SEP  = "─" * (_W + 16)
_DSEP = "═" * (_W + 16)


def _row(label: str, value: float, note: str = "") -> str:
    note_str = f"  [{note}]" if note else ""
    return f"  {label:<{_W}} ${value:>14,.2f}{note_str}"


def _pct_row(label: str, value: float) -> str:
    return f"  {label:<{_W}} {value:>14.2f}%"


def _header_line(label: str) -> str:
    return f"\n{label}"


def print_results(r: dict) -> None:
    fs_display = {
        "single":            "Single",
        "married":           "Married Filing Jointly",
        "head_of_household": "Head of Household",
    }
    state = r["state"]
    state_label = (
        f"{r['state_code']} ({state['name']})"
        if r["state_code"] and state.get("name")
        else "None (federal only)"
    )

    print(f"\nTax Year: {r['year']}  |  "
          f"Filing Status: {fs_display[r['filing_status']]}  |  "
          f"State: {state_label}")
    print()
    print(_row("Salary:", r["salary"]))
    print(_row("Stock Sales (LTCG):", r["stock_sales"]))
    print(_row("Gross Income:", r["gross_income"]))
    print(_SEP)

    print(_header_line("Federal Tax:"))
    print(_row("Standard Deduction:", r["standard_deduction"]))
    print(_row("Federal Taxable Income:", r["federal_taxable_income"]))
    print(_row("Federal Income Tax:", r["federal_income_tax"]))
    print(_row("Federal Capital Gains Tax:", r["federal_capital_gains_tax"]))
    print(_row("NIIT (3.8%):", r["niit"]))
    print(_SEP)

    amt = r["amt"]
    print(_header_line("AMT Detail:"))
    print(_row("AMTI (no deductions):", amt["amti"]))
    print(_row("Reduced AMT Exemption:", amt["reduced_exemption"]))
    print(_row("Net AMTI:", amt["net_amti"]))
    print(_row("  Ordinary Net AMTI:", amt["ordinary_net_amti"]))
    print(_row("  LTCG in AMTI:", amt["ltcg_in_amti"]))
    print(_row("AMT on Ordinary (26/28%):", amt["amt_ordinary"]))
    print(_row("AMT on LTCG:", amt["amt_ltcg"]))
    print(_row("Tentative Minimum Tax:", amt["tentative_minimum_tax"]))
    print(_row("Regular Tax (for AMT comparison):", amt["regular_tax_for_comparison"]))
    amt_note = "AMT applies" if amt["amt_applies"] else "does not exceed regular tax"
    print(_row("Additional AMT:", r["additional_amt"], note=amt_note))
    print(_SEP)

    print(_row("Total Federal Tax:", r["total_federal_tax"]))
    print(_SEP)

    # --- State section ---
    if not r["state_code"]:
        print(_header_line("State Tax:"))
        print("  (no state specified)")
    elif state["no_income_tax"]:
        reason = state.get("reason", "")
        if reason == "state_not_in_data":
            msg = f"'{r['state_code']}' not found in {r['year']} data — no state tax applied"
        else:
            msg = "no state income tax"
        print(_header_line(f"{state.get('name', r['state_code'])} State Tax:"))
        print(f"  ({msg})")
    elif state.get("capital_gains_only"):
        print(_header_line(f"{state['name']} State Tax (Capital Gains Only):"))
        print(_row("  CG Exemption Threshold:", state["cg_deduction"]))
        print(_row("  Taxable Capital Gains:",
                   max(0.0, r["stock_sales"] - state["cg_deduction"])))
        print(_row("  Capital Gains Tax:", state["total_state_tax"]))
    else:
        print(_header_line(f"{state['name']} State Tax:"))
        print(_row("State Deduction:", state["state_deduction"]))
        print(_row("State Taxable Income:", state.get("state_taxable_income", 0.0)))
        print(_row("State Income Tax:", state["state_income_tax"]))
    print(_row("Total State Tax:", r["total_state_tax"]))
    print(_SEP)

    print(_DSEP)
    print(_row("Total Tax (Federal + State):", r["total_tax"]))
    print(_pct_row("Effective Tax Rate:", r["effective_tax_rate"]))
    print(_row("Gross Income:", r["gross_income"]))
    print(_row("Estimated Take-Home Pay:", r["take_home_pay"]))
    print()


# ---------------------------------------------------------------------------
# CLI
# ---------------------------------------------------------------------------

def main() -> None:
    today = datetime.date.today()
    years = supported_years()
    default_year = today.year if today.year in years else max(years)

    parser = argparse.ArgumentParser(
        description=(
            "Estimate federal and state taxes for salary + long-term capital gains. "
            "Requires tax_data.yaml (run build_tax_data.py to generate it)."
        ),
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=(
            "Examples:\n"
            "  %(prog)s 200000 100000 --state CA\n"
            "  %(prog)s 300000 500000 --year 2025 --state NY --filing-status married\n"
            "  %(prog)s 150000 0 --state TX\n"
        ),
    )
    parser.add_argument("salary", type=float, help="Annual W-2 salary")
    parser.add_argument(
        "stock_sales",
        type=float,
        help="Long-term capital gains (proceeds minus cost basis)",
    )
    parser.add_argument(
        "--year",
        type=int,
        default=default_year,
        help=f"Tax year. Available: {years}. Default: {default_year}",
    )
    parser.add_argument(
        "--state",
        type=str,
        default=None,
        metavar="STATE",
        help=(
            "Two-letter state postal code (e.g. CA, NY, WA). "
            "Omit to calculate federal only."
        ),
    )
    parser.add_argument(
        "--filing-status",
        type=str,
        default="single",
        choices=FILING_STATUSES,
        metavar="STATUS",
        help=f"Filing status: {', '.join(FILING_STATUSES)}. Default: single",
    )

    args = parser.parse_args()

    if args.salary < 0:
        parser.error("salary must be non-negative")
    if args.stock_sales < 0:
        parser.error("stock_sales must be non-negative")

    state_code = args.state.upper() if args.state else None

    # Warn if year is outside supported range (data will already fail gracefully)
    if args.year not in supported_years():
        parser.error(
            f"Year {args.year} not supported. Available: {supported_years()}"
        )

    try:
        results = calculate_taxes(
            salary=args.salary,
            stock_sales=args.stock_sales,
            year=args.year,
            state_code=state_code,
            filing_status=args.filing_status,
        )
    except (ValueError, KeyError) as exc:
        print(f"Error: {exc}", file=sys.stderr)
        sys.exit(1)

    print_results(results)


if __name__ == "__main__":
    main()
